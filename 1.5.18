#Sean Towse 12.4.17
import time
import string
import random
def start():
    print "this is main, it handles everything"
    userName = getUserName()
    greetUser(userName)
    playerSkills = createCharacter(userName)
    main(playerSkills)
    return 
def main():
    theBigBookOfConstants()
    player(playerSkills)
    while playerAlive == true:
        getWalkDirection()
        if roomType == fight:
            enSkills = generateEnemeyWeighted(playerSkills, userEqu)
            en(enSkills)
            #store stats
            comabat(userSkills, userEqu, botSkills, botEqu)
            updateScore(winner)
            if playerAlive == false:
                displayGameOver()
                announceFinalResults(userName, userScore, computerScore)
                askForReplay(userName)
            if playerAlive == true:
                break
            break
        if roomType == loot:
            displayLoot(userName, userSkills, userEqu)
def theBigBookOfThings():
       #http://dwarffortresswiki.org/index.php/DF2014:Material_science#Effects_on_Combat  Material	Density	Impact Yield     2*(Impact Fracture) - Impact Yield	,Shear Fracture,Sharpness, Bolt	adj.	Sword	adj.	Mace	min M
    #http://www.bronze-age-swords.com/intro.htm
    mat ={ 
          Bronze : {"MatDen" : 8.25, "ImpY" : 0.60, "M" :1.08 , "ShFr" : 0.24, "Shar" : 1, "Sword" : 75, "sadj" : 18 , "Mace" : 138 , "minM" :43 },
          Copper : {"MatDen":8.93, "ImpY":0.25,"M": 1.30,"ShFr": 0.22,"Shar": 1,  "Sword":77, "sadj":17, "Mace":138,"minM":52},
          Iron : {"MatDen":7.85,"ImpY":0.54,"M": 1.62, "ShFr":0.31,"Shar":1,  "Sword":75, "sadj":23, "Mace":137, "minM" :65},
          Silver : {"MatDen":10.49,"ImpY":0.35,"M": 0.84, "ShFr":0.17,"Shar":1,"Sword":79,"sadj":13,"Mace":140,"minM":34},
          Steel : {"MatDen":7.85,"ImpY":1.51, "M":3.54,"ShFr":0.72,"Shar":1,"Sword":75,"sadj":54,"Mace":137,"minM":142}
          }
def en(enSkills,enEqu):
    if FirstTimeAlive == true:
        enParts = [Rarm, Larm, Lleg, Rleg, Head, Torso]
        enBlood# = 5500
        FirstTimeAlive = False
    if EnBlood <= 3850:
        for skill in dict.enSkills:
            skill = skill * (enBlood/5000) * 1.3
    if enBlood <= 3300:
        enAlive = false
    
    enEqu
    enSkills
    return enAlive, enSkills, enParts, enEqu
def player(playerSkills):
    print playerSkills
    userParts = [Rarm, Larm, Lleg, Rleg, Head, Torso]
    userEqu = {"defaultShirt" :{ "weight" : 1, "piercingRes" : 0 , "cuttingRes": 0}, "defaultPants" :{"weight" : 1, "piercingRes" : 0, "cuttingRes": 0, "defaultWepon":{"Weight": 800g , "sharpness" : 1000 , "length": 36 , "Blade Lenthg": 29, "matreal": bronze}}}
    return userEqu, 
    #M >= (rSY + (A+1)*rSF) * (10 + 2*Qa) / (S * Qw),
speedCaculation(userThrow, botThrow)
    M = Str * Vel / ( 106/180 + 10*F/W ),
    
def comabat(dictionaryGeneral, userskills, userEqu, enSkills, enEqu):
    print "this handles combat"
    userThrow = getPlayerThrow()
    botThrow = getBotThrow()
    caculations(userThrow)
    caculations(botThrow)
    
def caculations
    a= 
    if edged:
        A= 
        if M >= ((layerShFr*.5)/(weaponShFr*.5) + (A+1)*rSF) * 12 
            if M - ((layerShFr*.5)/(weaponShFr*.5) + (A+1)*layerSF/weaponSF) * 12 >= partthickness/resistance:
            if M - ((layerShFr*.5)/(weaponShFr*.5) + (A+1)*layerSF/weaponSF) * 12 < partthickness/resistance:    
            
        change to blunt
    if blunt 
        A = 
        if 2 * Sw * weaponImpY < A * layerMatDen
        if M >= (2*layerImpF - layerImpY) * (2 + 0.4*1) * A,
        
    
        #update dicotnary
    #if damage == dehablitating: 
       #skip turn for second
    #if it hits
       #apply debuff
      #caculations(botThrow)
      #calcuations baised of type of strike
      #if botThrow == first:
      #caculations(botthrow)
      #update dicotnary
      #if damage == dehablitating: 
          #skip turn for second
      #if damage == true:
          #apply debuff
      #caculations(userThrow)
  #do the next one
  #announce results of the round
    #update the player status
  #next tick
  #if player == dead
      #announce final results
      #say the game is over
def getUserName():
    #gets User's Name
    prompt = "what is your name young lad?"
    userName = raw_input(prompt)
    userName = string.capitalize(userName)
    return userName
def greetUser(userName):
    #code to greet the user goes here
    print "hello " + userName + ", let's go on an adventure!"
def createCharacter(userName):
    print "handles creation of the PC"
    skills = ['Int','Chr' ,'Str' ,'Con','Wis','Dex']
    userInputs= []
    #Make there be a limiting thing
    for key in skills:
        waitingForValid = true
        while waitingForValid:
            prompt = "how many points would you like to put into " + key + "? input 'help' for a skill guide"
            userInput = raw_input(prompt)
            if userInput == "help":
                print "ablity 1-5 very bad, 5-11 normal, 12-15 - Above Average, 16-19 - Genius-level, 20-23 - Superhuman, 24+ - crazy good"
                userInput = raw_input(prompt)
            isItANumber = userInput.isnumeric()
            if isItANumber:
            
                waitingForValid == false
                userInputs.append(userInput)
                break
            if  isItANumber == false:
                print "that is not a int, please input an int"
    playerSkills = dict(zip(skills, userInputs)) 
    print playerSkills
    return playerSkills
def generateEnemeyWeighted(playerSkills, userEqu):
    print "grenerates an enamy baised on the PC's lvl and equ"
    skills = ['Int','Chr' ,'Str' ,'Con','Wis','Dex']
    enskill = []
    playerSkills
    for item in playerSkills.iteritem:
        enSkillChange = random.randint(1,201)
        enSkillChange = enSkillChange/100
        enskill = enSkillChange * item
        enSkill.append(enskill)
    #run a loop about chooseing each of these 
    enSkills = dict(zip(skills, enskill)) 
    
    enequ = []
    print enSkills
    return enSkills
def whichWayToWalk():
    promt = "witch way would you like to walk? North, South, East, or West"
    userInput = raw_input(promt)
    strSanatazers(userInput)
    if north or south or east or west in userInput:
        randEncouter()
def randEncouter(userName):
    print "genrates a radom encounter"
    roomNum = random.randint(0,1)
    roomTypeList = [fight, loot]
    roomType = roomNum[roomTypeList]
    return roomType
def displayLoot(, userEqu):
   print "AWW SHUCKS"
   whatisItList = [gear, weapon]
   whatIsItNum = 
   whatIsIt = whatIsItNum(whatIsItList)
   if whatIsIt == gear:
        whatIsitForList = [head, torso, Rarm, Larm, Hands, Rleg, Lleg, Neck]
        whatIsItForNum = 
        whatIsitFor = WhatIstItForNum(WhatIsItForList)
        whatIsitForList = [Iron, Steel, Bronze, Copper,Iron, Steel, Bronze, Iron, Steel, Bronze, Copper, Glass, Iron, Iron]
        whatIsItForNum = 
        whatIsitMat = WhatIstItForNum(WhatIsItForList)
        prompt = "would you like to pickup this" + whatisit + "? It is made from" + whatIsItMat + "if so say 'yes'"
        userInput = raw_Input(prompt)
        if userInput == yes: 
            userequ.update({str(whatIsItFor): whatIsItMat })
   if whatIsIt == weapon:
        whatIsitForList = [Iron, Steel, Bronze, Copper,Iron, Steel, Bronze, Iron, Steel, Bronze, Copper, Glass, Iron, Iron]
        whatIsItForNum = 
        whatIsitMat = WhatIstItForNum(WhatIsItForList)
        whatIsitForList = [sword, Mace]
        whatIsItForNum = 
        whatIsitMat = WhatIstItForNum(WhatIsItForList)
        prompt = "would you like to pickup this" + whatisit + "? It is made from" + whatIsItMat + "if so say 'yes'"
        userInput = raw_Input(prompt)
        if userInput == yes: 
            userequ.update({"weapon": })
   
   return userEqu
def getUserThrow(enParts):
    print "asks and hands off to cacuations the users throw"
    #code to get the user's throw goes here
    promt = "where would you like to attack you enamy?" + enParts + "choose one of these"
     

    #this is the return statement that will send the value back
    return userThrow


def getComputerThrow(throwListPC):
    print "asks and hands off to cacuations the computer throw"
    #code to get the computer's throw goes here
    
    
    #this is the return statement that will send the value back
    return computerThrow
def whoHitsFirst(userthrow, userEqu,botThrow, botEqu):
    print "who hits first"
    #take the speed of bolth, find who hits first and retun boolth
        #
    return firstToHit & secondToHit 
def calculations(strikeFirstToHit):
    print "caculates damage"
    M = fhS * fhL * fhWW
    rsy = strikeFirstToHit/ 
    if strike == Sharp:
        if M >= (rSY + (A+1)*rSF) * (10 + 2*Qa) / (S * Qw):
            #cut through
        if M < (rSY + (A+1)*rSF) * (10 + 2*Qa) / (S * Qw):
                strike = blunt 
                M = M * SHEAR_STRAIN_AT_YIELD/50000
                
where:

rSY is the ratio of layer's to weapon's SHEAR_YIELD
rSF is ditto with SHEAR_FRACTURE
A is attack contact area
S is weapon material sharpness multiplier (1x for most metals, 1.2x for divine metal, 1.5x for glass, 2x for obsidian, 10x for adamantine and 0.1x for all other materials)
Qw is quality sharpness multiplier (1x for normal quality, 1.4x for fine, 2x for masterwork (or artifact) etc.)
Qa is armor quality multiplier (same but x3 for artifacts)
    if strike == blunt:
        Blunt attacks can be entirely deflected by armor if weapon's IMPACT_YIELD is especially low relative to armor's density:
        if WeponImpY/ == 
         2 * Sw * IYw < A * Da,

where Da is armor material's density (in g/cm3), A is attack contact area, Sw is weapon size and IYw is its impact yield in MPa (i.e. raw value divided by 106).

Otherwise, attack must have minimum momentum of:

M >= (2*IF - IY) * (2 + 0.4*Qa) * A,

where IF and IY are layer's impact fracture and impact yield in MPa, Qa is armor quality multiplier and A is contact area as above. Again, on success layer is considered thrashed, momentum is reduced by about 5% and next layer is tested.
    #if siccusful
        #use points hit and spead AFTER armour pen to cacualte tissue dmg 
        #apply debuff to effected party 
        #stop other attack?
            #if on limb delivering attack
    # return damage
def announceRoundResults(damagePC, damageEn):
    "tells user results of the round"
#code to display the winner of the round goes here


#there is nothing to return from this function


def updateScore(winner, userScore, computerScore):
    #code to u0pdate the score goes here
    print("This is the updateScore function")
    print("The winner is "+ winner)
    print("The value of userScore is "+ str(userScore))
    print("The value of computerScore is "+ str(computerScore))

    #this is the return statement that will send the values back
    return userScore, computerScore



def askForReplay(userName):
    print "asks for replay"
    #code to ask if user wants to play again goes here


    #this is the return statement that will send the value back
    return replayDesired


def announceFinalResults(userName, userScore, computerScore):
    print "annonces final resuls:"
    #code to announce final results goes here



    #there is nothing to return from this function




def displayGameOver():
    print "game over"
    #code to say game is over goes here
    #you could do that simply with printing to the console, but you might also want to do it with music, pictures, or maybe the turtle!


    #there is nothing to return from this function
